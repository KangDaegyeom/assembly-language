어셈블러
어셈블러(assembler)는 니모닉 기호(mnemonics)를 opcode로 변환하고 메모리 위치와 기타 존재물에 따라 식별자를 다시 분석함으로써 목적 코드를 만들어낸다.[2] 거꾸로 기계어를 어셈블리어로 바꾸는 것은 “역(逆)어셈블러”(disassembler)이다. 고급 언어와는 달리 어셈블리어는 간단한 문장에 대해 기계어와 일대일 대응 관계가 있지만, 자주 쓰이는 몇 명령은 둘 이상의 기계어 명령을 묶어 하나의 어셈블리 명령어에 대응시키기도 한다.

패스의 수
어셈블러에는 두 가지 종류가 있는데, 실행 프로그램을 만들기 위해 얼마나 많은 패스가 소스를 거치는지에 따라 다르다.

1패스(one-pass) 어셈블러는 소스 코드를 한 번만 거친다.
다중 패스(multi-pass) 어셈블러는 처음 패스들에서 모든 기호와 관련 값들이 포함된 테이블 하나를 만들고 나중 패스들에서 테이블을 이용하여 코드를 만들어낸다.
1패스 어셈블러들을 이용하는 본래 이유는 어셈블리의 속도 때문이다. 2차 패스가 되돌아가기를 요구할 수도 있기 때문이다. 그러나 현대의 컴퓨터는 납득하기 어려운 지연 없이 다중 패스 어셈블리를 수행한다. 다중 패스 어셈블러는 링크 프로세스를 더 빠르게 한다는 장점이 있다.[3]

고급 어셈블러
더 복잡한 고급 어셈블러는 다음과 같은 언어 추상물을 제공한다:

진보화된 제어 구조
높은 수준의 프로시저/함수 선언 및 호출
구조/레코드, 유니언(union), 클래스, 집합을 포함한 높은 수준의 추상 자료형
복잡한 매크로 처리
클래스, 오브젝트, 추상화, 다형성, 상속과 같은 객체 지향 프로그래밍 기능[4]
어셈블리어
기계어는 실제로 컴퓨터의 CPU가 읽어서 실행할 수 있는 0과 1로 이루어진 명령어의 조합이다. 이러한 각 명령어에 대해 사람이 알아보기 쉬운 니모닉 기호(mnemonic symbol)를 정해 사람이 좀 더 쉽게 컴퓨터의 행동을 제어할 수 있도록 한 것이 어셈블리 언어이다.

예를 들어,

10110000 01100001
는 x86 계열 CPU의 기계어 명령이고, 이것을 어셈블리어로 옮겨쓰면 다음과 같다.

mov al, 061h
명령어 mov는 영어 move를 변형한 니모닉이며, al은 CPU안에 있는 변수를 저장하는 레지스터의 하나이다. 그리고, 061h는 16진수 61 (즉 십진수 97, 이진수 01100001)이다. 이 한 줄의 뜻은 16진수 61을 al레지스터에 넣으라는 뜻이며, 1과 0의 반복인 기계어보다 사람이 혼동없이 이해하기 한결 쉽다. 어셈블리어는 이러한 문장들로 구성된다.